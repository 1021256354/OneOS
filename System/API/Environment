--[[

This essentially allows the programs to run in sandbox. For example, os.shutdown doesn't shut the entire computer down. Instead, it simply stops the program.

]]

	local errorHandler = function(apiName, name, value)
		if type(value) ~= 'function' then
			return value
		end
		return function(...)local response = {pcall(value, ...)}
					local ok = response[1]
					table.remove(response, 1)
					if ok then
						return unpack(response)
					else
						for i, err in ipairs(response) do
							printError(apiName .. ' Error ('..name..'): /System/API/' .. err)
						end
							
					end
				end
	end

	function addErrorHandler(api, apiName)
		local newApi = {}
		for k, v in pairs(api) do
			newApi[k] = errorHandler(apiName, k, v)
		end
		return newApi
	end

	Initialise = function(self, program, shell, path)
		local env = {}    -- the new instance
		setmetatable( env, {__index = _G} )

		env.fs = addErrorHandler(self.FS(env, program, path), 'FS API')
		env.os = addErrorHandler(self.OS(env, program), 'OS API')
		env.loadfile = function( _sFile, global)
			local file = env.fs.open( _sFile, "r", global)
			if file then
				local func, err = loadstring( file.readAll(), env.fs.getName( _sFile, global) )
				file.close()
				return func, err
			end
			return nil, "File not found"
		end
		env.shell = {}
		local shellEnv = {}
		setmetatable( shellEnv, { __index = env } )
		setfenv(self.Shell, shellEnv)
		self.Shell(env, program, shell, path)
		env.shell = addErrorHandler(shellEnv, 'Shell')
 		env.OneOS = addErrorHandler(self.OneOS(env, program), 'OneOS API')
		env.sleep = env.os.sleep
		return env
	end

	OneOS = function(env, program)
		return {
			ToolBarColour = colours.white,
			ToolBarTextColour = colours.black,
			OpenFile = Helpers.OpenFile,
			Helpers = Helpers,
			Desktop = Desktop,
			Settings = Settings,
			Version = OneOSVersion,
			Restart = Restart,
			Reboot = Restart,
			Shutdown = Shutdown,
			Clipboard = Clipboard,
			CanClose = function()end,
			Close = function()
				program:Close()
			end
		}
	end

	FS = function(env, program, path)
		local relPath = path:sub(1, #path-7)
		local list = {}
		for k, f in pairs(fs) do
			if k ~= 'open' and k ~= 'combine' then
				list[k] = function(_path, global)
					if not global then
						return fs[k](relPath .. _path)
					else
						return fs[k](_path)
					end
				end
			elseif k == 'combine' then
				list[k] = function(_path, _path2)
					return fs[k](_path, _path2)
				end
				--[[
				function(_path, _path2, global)
					if global then
						return fs[k](relPath .. _path, relPath .. _path2)
					else
						return fs[k](_path, _path2)
					end
				end
				]]--
			elseif k == 'open' then
				list[k] = function(_path, mode, global)
					if not global then
						return fs[k](relPath .. _path, mode)
					else
						return fs[k](_path, mode)
					end
				end
			end
		end
		return list
	end

	OS = function(env, program)
		local tAPIsLoading = {}
		_os = {

			version = function()
				return 'OneOS Shell 1.0'
			end,

			getComputerID = os.getComputerID,

			getComputerLabel = os.getComputerLabel,

			setComputerLabel = os.setComputerLabel,

			run = os.run,-- function(env, prg, arg)end,

			loadAPI = function(_sPath, global)
				local _fs = fs
				if not global then
					_fs = env.fs
				end

				local sName = _fs.getName( _sPath)
				if tAPIsLoading[sName] == true then
					printError( "API "..sName.." is already being loaded" )
					return false
				end
				tAPIsLoading[sName] = true
					
				local tEnv = {}
				setmetatable( tEnv, { __index = env } )
				tEnv.fs = _fs
				local fnAPI, err = env.loadfile( _sPath, global)
				if fnAPI then
					setfenv( fnAPI, tEnv )
					fnAPI()
				else
					printError( err )
			        tAPIsLoading[sName] = nil
					return false
				end
				
				local tAPI = {}
				for k,v in pairs( tEnv ) do
					tAPI[k] =  v
				end
				
				env[sName] = tAPI

				tAPIsLoading[sName] = nil
				return true
			end,


			os.unloadAPI,

			pullEvent = function(target)
				--print(target)
				--print('!')
				local eventData = { coroutine.yield(target) }
				--print(eventData[1])
				--print('*')
				if eventData[1] == "terminate" then
					error( "Terminated", 0 )
				end
				return unpack( eventData )
			end,

			pullEventRaw = function(target)
				return coroutine.yield(target)
			end,

			queueEvent = function(...)
				program:QueueEvent(...)
			end,

			clock = function()
				return os.clock()
			end,

			startTimer = function(time)
				local timer = os.startTimer(time)
				table.insert(program.Timers, timer)
				return timer
			end,

			time = function()
				return os.time()
			end,

			sleep = function(time)
			    local timer = _os.startTimer( time )
				repeat
					local sEvent, param = _os.pullEvent( "timer" )
				until param == timer
			end,

			day = function()
				return os.day()
			end,

			setAlarm = function(timer)

			end,

			shutdown = function()
				print()
				term.setTextColour(colours.red)
				print('The program has shutdown.')
				program:Kill()				
			end,

			reboot = function()

			end
		}
		return _os
	end

	Shell = function(env, program, nativeShell, path)
		
		local parentShell = nil--nativeShell

		local bExit = false
		local sDir = (parentShell and parentShell.dir()) or ""
		local sPath = (parentShell and parentShell.path()) or ".:/rom/programs"
		local tAliases = (parentShell and parentShell.aliases()) or {}
		local tProgramStack = {path}

		-- Colours
		local promptColour, textColour, bgColour
		if term.isColour() then
			promptColour = colours.yellow
			textColour = colours.white
			bgColour = colours.black
		else
			promptColour = colours.white
			textColour = colours.white
			bgColour = colours.black
		end


		local function _run( _sCommand, ... )
			local sPath = nativeShell.resolveProgram( _sCommand )
			if sPath ~= nil then
				tProgramStack[#tProgramStack + 1] = sPath
		   		local result = os.run( env, sPath, ... )
				tProgramStack[#tProgramStack] = nil
				return result
		   	else
		    	printError( "No such program" )
		    	return false
		    end
		end

		local function runLine( _sLine )
			local tWords = {}
			for match in string.gmatch( _sLine, "[^ \t]+" ) do
				table.insert( tWords, match )
			end

			local sCommand = tWords[1]
			if sCommand then
				return _run( sCommand, unpack( tWords, 2 ) )
			end
			return false
		end

		-- Install shell API
		function run( ... )
			return runLine( table.concat( { ... }, " " ) )
		end

		function exit()
		    bExit = true
		end

		function dir()
			return sDir
		end

		function setDir( _sDir )
			sDir = _sDir
		end

		function path()
			return sPath
		end

		function setPath( _sPath )
			sPath = _sPath
		end

		function resolve( _sPath, global)
			print(_sPath)
			print(sDir)
			print(env.fs.combine(sDir, _sPath))
			local sStartChar = string.sub( _sPath, 1, 1 )
			if sStartChar == "/" or sStartChar == "\\" then
				return env.fs.combine( "", _sPath, global)
			else
				return env.fs.combine( sDir, _sPath, global)
			end
		end

		function resolveProgram( _sCommand )
			-- Substitute aliases firsts
			if tAliases[ _sCommand ] ~= nil then
				_sCommand = tAliases[ _sCommand ]
			end

		    -- If the path is a global path, use it directly
		    local sStartChar = string.sub( _sCommand, 1, 1 )
		    if sStartChar == "/" or sStartChar == "\\" then
		    	local sPath = fs.combine( "", _sCommand )
		    	if fs.exists( sPath ) and not fs.isDir( sPath ) then
					return sPath
		    	end
				return nil
		    end
		    
		 	-- Otherwise, look on the path variable
		    for sPath in string.gmatch(sPath, "[^:]+") do
		    	sPath = fs.combine( nativeShell.resolve( sPath ), _sCommand )
		    	if fs.exists( sPath ) and not fs.isDir( sPath ) then
					return sPath
		    	end
		    end
			
			-- Not found
			return nil
		end

		function programs( _bIncludeHidden )
			local tItems = {}
			
			-- Add programs from the path
		    for sPath in string.gmatch(sPath, "[^:]+") do
		    	sPath = nativeShell.resolve( sPath )
				if fs.isDir( sPath ) then
					local tList = fs.list( sPath )
					for n,sFile in pairs( tList ) do
						if not fs.isDir( fs.combine( sPath, sFile ) ) and
						   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= ".") then
							tItems[ sFile ] = true
						end
					end
				end
		    end	

			-- Sort and return
			local tItemList = {}
			for sItem, b in pairs( tItems ) do
				table.insert( tItemList, sItem )
			end
			table.sort( tItemList )
			return tItemList
		end

		function getRunningProgram()
			if #tProgramStack > 0 then
				return tProgramStack[#tProgramStack]
			end
			return nil
		end

		function setAlias( _sCommand, _sProgram )
			tAliases[ _sCommand ] = _sProgram
		end

		function clearAlias( _sCommand )
			tAliases[ _sCommand ] = nil
		end

		function aliases()
			-- Add aliases
			local tCopy = {}
			for sAlias, sCommand in pairs( tAliases ) do
				tCopy[sAlias] = sCommand
			end
			return tCopy
		end
			
--[[
		term.setBackgroundColor( bgColour )
		term.setTextColour( promptColour )
		print( os.version() )
		term.setTextColour( textColour )

		-- Read commands and execute them
		local tCommandHistory = {}
		while not bExit do
			term.setBackgroundColor( bgColour )
			term.setTextColour( promptColour )
			write( nativeShell.dir() .. "> " )
			term.setTextColour( textColour )

			local sLine = read( nil, tCommandHistory )
			table.insert( tCommandHistory, sLine )
			runLine( sLine )
		end
]]--

		--os.shutdown() -- just in case

	end